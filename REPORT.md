### Notes/Decisions/Trade-offs/Problems
- Had to update my Go version to 1.22 since my current 1.20 does not parse the go.mod well. (go.mod:3: invalid go version '1.21.5': must match format 1.23)
-   Another version issue, `[https://github.com/cosmtrek/air`](https://github.com/cosmtrek/air%60) (which deals with live reloads for Gin) requires go version > 1.22. I read the CHANGELOG (this is the particular PR: https://github.com/cosmtrek/air/pull/462) of for v1.49.0 -> 1.50.0 and saw that it interprets the kill_delay for reloading as nanoseconds instead of milliseconds which might be a bit too quick (currently set as 500). So I decided to update the Go version instead from 1.21.5 to 1.22.1 and use the latest version of air.
-   To streamline development, I want to load the CSV files into the database once the container is built. `docker-entrypoint-initdb.d` directory executes .sql files inside so we’re going to use this to load tables and data upon initialization.
-   Decided to store location data as POINT instead of having separate columns for longitude and latitude so I could compute the distance radius easier. However, it seems I would need to use raw SQL queries since it looks like Gorm doesn’t have support for ST_Distance_Sphere yet.
-   Noticed that [locations.id](http://locations.id) is defined as string(36) instead of being int which I assumed since all sample data has numerical IDs. Anyway, I rewrote `init.sql` and reinitialize the mysql container but I encountered an issue (“The designated data directory /var/lib/mysql/ is unusable”) with the Mysql container not starting after testing the DB initialization. Decided to just prune the volume since it might be corrupted and data can be initialized again anyways afterwards.
-   Noticed that the UID is defined in the specs as string(36) even if the sample data only has 14 characters. Decided to just leave it at VARCHAR(36) since I’m not sure about the specifics on how the UID is defined.
-   Spent some amount of time debugging only to find out that MySQL stores spatial point data as longitude and latitude.
- Included `distance` in the SELECT clause so we can sort by nearest. Though according to the challenge specs, it's not needed so not including the response.
-   Prepared Interfaces for mock testing
-   To get the EVSEs, I decided to use GROUP_CONCAT to have all EVSEs in one comma-separated string and just parse each record in the code to map it in the EVSEs object.
-   Made response objects for location and evses to have better control over the response.
-   Changed my mind about GROUP_CONCAT (GROUP_CONCAT(CONCAT_WS(',', e.uid, e.status)) as evses) since I’m looping them with a FOR loop that iterates with 2 everytime due to string being comma-separated with two values each. Read about JSON_ARRAYAGG and JSON_OBJECT and decided to use it since you can Unmarshal it straight to a JSON object inside Go.
-   After re-reading the challenge specs, I noticed that we shouldn’t display locations without EVSEs. Tested a few times and noticed that query was including locations with no linked EVSEs so added “MAX(e.uid IS NOT NULL)” since the query will automatically include a {uid: null, status: null} JSON object if no EVSEs were found for a location.